###### vscode快捷键

SHIFT + ALT + 单击：在选定的每行末尾插入光标

CTRL+L:选中当前行

CTRL+F2:选择所有出现的当前单词

##### 常识

###### lib文件夹

lib是library的缩写，意思是库文件

###### 网页版设计图

网页版设计图如果老是变换成百分比就长按alt切换

###### 框架和插件的区别

框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。

插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。

###### ip地址、域名和url的区别

![snipaste20220317_141227](笔记截图\snipaste20220317_141227.png)

* 总结：IP地址=域名=计算机的身份证；url是你这台计算机上资源存放的具体位置，它的前半段是ip地址，后半段是具体的地址

### web标准

###### 为什么要web标准？

不同浏览器的渲染引擎不同，对于相同代码解析的效果会存在差异。如果用户想看一个网页，结果用不同浏览器打开效果不同，用户体验极差！

###### 什么是web标准？

让不同的浏览器按照相同的标准显示结果，让展示的效果统一！

###### Web标准的构成

![snipaste20220309_091906](笔记截图\snipaste20220309_091906.png)

### W3C标准

![2022-03-21_183604](笔记截图/2022-03-21_183604.png)

### html、xhtml的区别

xhtml是对html的扩展

### Html

###### 标题标签h

###### 段落标签p

###### 水平线标签hr

###### 换行标签br

###### 文本格式化标签(标签语义化)

```
<strong></strong>
<i></i>倾斜
<em></em>强调（strong的语气更强）
 <del></del>删除线
都是行内标签，不然怎么叫文本标签呢
```

###### img标签

###### audio标签

###### video标签

###### 无序列表

ul>li

###### 有序列表

ol>li

###### 自定义列表

```
<dl>
<dt></dt>
<dd></dd>
</dl>
```

###### 表格

```
<table>
        <th><tr><td></td></tr></th>
        <tbody>
            <tr><td></td></tr>
        </tbody>
    </table>
```

#### 表单标签

就是嵌套在表单内部的标签，主要和表单form一起使用，所以叫表单标签

##### input标签

###### 文本框

![snipaste20220315_145225](笔记截图\snipaste20220315_145225.png)

###### 密码框

![snipaste20220315_145253](笔记截图\snipaste20220315_145253.png)。

###### 单选框

![snipaste20220315_145317](笔记截图\snipaste20220315_145317.png)

* 有相同name属性值的单选框为一组，一组只能同时有一个被选中

  ![snipaste20220318_083205](笔记截图\snipaste20220318_083205.png)

###### 多选框

![snipaste20220315_145348](笔记截图\snipaste20220315_145348.png)

多选框的状态属性：checked，this.checked=true//选中，this.checked=false//未选中

###### 文件选择框

![snipaste20220315_145407](笔记截图\snipaste20220315_145407.png)

###### 表单按钮

![snipaste20220315_145448](笔记截图\snipaste20220315_145448.png)



##### button标签

![snipaste20220316_130139](笔记截图\snipaste20220316_130139.png)

###### button标签和input标签中的表单按钮的区别

我觉得是完全一样的，随便用哪种

##### 下拉菜单

![snipaste20220316_130210](笔记截图\snipaste20220316_130210.png)

##### 文本域标签

![snipaste20220316_130240](笔记截图\snipaste20220316_130240.png)

##### label标签

![snipaste20220316_130350](笔记截图\snipaste20220316_130350.png)

![snipaste20220318_083423](笔记截图\snipaste20220318_083423.png)

#### div标签

#### span标签

#### 字符实体

###### 空格

&nbsp ;

###### 大于号

& gt;

###### 小于号

& lt;

#### li标签

如果不给宽高的话，它不像其他标签一样能够继承父级，它并不会继承，只会刚好包住里面的内容。

### css

###### div相关

div如果当中什么内容也没有，那么它在浏览器中是不显示的；

div中有内容才会显示，它的宽是继承父级的，它的高是根据内容的高来定的；

###### 字体图标的使用

下载方式见ppt

使用步骤：

![snipaste20220306_142928](笔记截图\snipaste20220306_142928.png)

###### 精灵图的使用

使用步骤

* 创建一个和图片大小相同的盒子；
* 设置background-image；
* 更改显示模式；
* 利用backg-position调整位置；

###### 网站logo写法

![snipaste20220221_103201](笔记截图\snipaste20220221_103201.png)

![snipaste20220221_103214](笔记截图\snipaste20220221_103214.png)

###### 背景图片大小

![snipaste20220221_104445](笔记截图\snipaste20220221_104445.png)

##### 伪类选择器

###### hover伪类选择器

只能给a标签使用，其他标签不生效

###### 结构伪类选择器

![snipaste20220222_151442](笔记截图\snipaste20220222_151442.png)

##### 伪元素

用途：一般页面中的非主体内容可以使用伪元素

::before和::after

![snipaste20220308_194448](笔记截图\snipaste20220308_194448.png)

##### 居中问题

###### 水平居中

法一：

![snipaste20220222_103631](笔记截图\snipaste20220222_103631.png)

注：能水平居中的元素都是行内元素或者行内块元素

法二：

利用flex布局->调整父级元素的justify-content属性值为center

###### 垂直居中

法一：

* ![snipaste20220222_133536](笔记截图\snipaste20220222_133536.png)

  注：能用line-height属性居中的元素应该是行内元素或者行内块元素

  ![snipaste20220309_093309](笔记截图\snipaste20220309_093309.png)

  法二：

* ![snipaste20220219_172558](笔记截图\snipaste20220219_172558.png)

bottom：把元素的顶端与行中最低的元素的顶端对齐。（给位置更高的元素设置vertical-align，因为要高的去和低的对齐。给位置低的去设置无效）

top： 把元素的顶端与行中最高元素的顶端对齐（给位置更低的元素去设置，低的要去找高的）

middle：把此元素放置在父元素的中部。

法三：

利用flex布局，将父元素/子元素的align-items/align-self的值改为center

优点是什么？

不需要考虑它到底是块级元素还是行内元素了

##### img标签

img标签有行内块元素的特点，但是调试工具中显示默认显示模式为inline

##### input标签

显示模式为行内块元素

##### 文本

文本也一定要看成一个标签

理解：

如< div>< span >你好啊< /span >< /div>

要理解为span标签中嵌套一个文本标签

你给div设置行高的时候，span和文本标签均会垂直居中，因为两者都是行内元素，行内元素的父级给行高会有垂直居中的效果

![snipaste20220309_094034](笔记截图\snipaste20220309_094034.png)

但是如果将span转化为块级元素，span不会居中，而其中的文本依然居中，所以要把文本单独理解为一个标签元素

![snipaste20220309_094259](笔记截图\snipaste20220309_094259.png)

##### i标签

是一个行内标签

##### a标签

在为a标签添加padding时一定要转换显示模式，否则padding不生效

同样的，别的行内元素在添加padding时也要转换显示模式

##### 外边距问题

###### 外边距合并现象

![snipaste20220226_090122](笔记截图\snipaste20220226_090122.png)

###### 外边距塌陷问题

![snipaste20220226_090241](笔记截图\snipaste20220226_090241.png)

##### 二倍图

###### 为什么要二倍图

为了防止图片失真

你是在逻辑尺寸上开发的，逻辑尺寸为实际物理尺寸的一半

设计师不可能按照逻辑尺寸来设计原型图，这样会失真，他肯定是按照物理尺寸来设计的

在你进行开发的时候因为是按照逻辑尺寸进行开发的，所以要把设计师的原型图调成一半

###### 二倍图的使用

![snipaste20220306_150155](笔记截图\snipaste20220306_150155.png)

#### 布局方式有哪些？/布局模型

##### 流动模型（Flow）

##### 浮动模型 (Float)

###### 清除浮动

1. 产生问题的条件

   父子级标签，子级浮动，父级没有高度，后面的标准流盒子会受影响

   [最新前端开发入门教程，web前端零基础html5 +css3+前端项目视频教程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Kg411T7t9?p=124)

###### 清楚浮动的方法

1. 直接设置父元素高度

2. 额外标签法

   ![snipaste20220319_085508](笔记截图\snipaste20220319_085508.png)

3. 单伪元素清楚法

   ![snipaste20220319_085709](笔记截图\snipaste20220319_085709.png)

4. 双伪元素清楚法

![snipaste20220319_085844](笔记截图\snipaste20220319_085844.png)

5. overflow:hidden;

直接调用clearfix类即可

##### 层模型（Layer）

1、相对定位(position: relative) 

2、绝对定位(position: absolute)

3、固定定位(position: fixed)

##### Flex模型

Flex-flexible-灵活

###### 优势

避免浮动脱标的问题

###### 怎样修改盒子之间的间距？

通过修改主轴或侧轴的对齐方式分别来调整盒子的左右间距和上下间距

* 调整主轴对齐方式来调整盒子的左右间距

  ![snipaste20220308_191312](笔记截图\snipaste20220308_191312.png)

  1. center：居中排列

     ![snipaste20220308_195239](笔记截图\snipaste20220308_195239.png)

  2. space-around：空白间距均分在盒子两侧

     ![snipaste20220308_195416](笔记截图\snipaste20220308_195416.png)

  3. space-between

     ![snipaste20220308_200642](笔记截图\snipaste20220308_200642.png)

  4. space-evenly

     ![snipaste20220308_200924](笔记截图\snipaste20220308_200924.png)

* 通过调整侧轴对齐方式来调整盒子的上下间距

  ![snipaste20220308_201707](笔记截图\snipaste20220308_201707.png)

  

  

  添加到弹性容器相当于是添加给父级，效果是为了控制父级内的子级的排列方式；

  align-items: center;

  ![snipaste20220308_201945](笔记截图\snipaste20220308_201945.png)

  

  

  添加到弹性盒子相当于给自己单独设置排列效果；

  ​      align-self: center;只给第一个盒子添加了

  ![snipaste20220308_202232](笔记截图\snipaste20220308_202232.png)
  
  注：flex这个显示模式是不会继承给子级的，如果继承给自己那还不完蛋
  
  ![snipaste20220309_095247](笔记截图\snipaste20220309_095247.png)
  
  给红盒子添加了flex布局，使粉盒子居中，粉盒子如果继承了flex属性，那也就居中了，但事实上是没有的。

###### 	伸缩比？？？（没有很明确的语言来描述这个东西）

![snipaste20220308_203655](笔记截图\snipaste20220308_203655.png)

注意是给子盒子添加felx=1，不是给父盒子添加，父盒子添加的是display：felx

![snipaste20220308_203814](笔记截图\snipaste20220308_203814.png)

注意：盒子的padding和margin都不算在父盒子剩余尺寸中



margin的情况

![snipaste20220308_204047](笔记截图\snipaste20220308_204047.png)



padding的情况

![snipaste20220308_204250](笔记截图\snipaste20220308_204250.png)

#### ！important

![snipaste20220309_191633](笔记截图\snipaste20220309_191633.png)

#### 使用flex-direction改变元素排列方向

![snipaste20220313_151451](笔记截图\snipaste20220313_151451.png)

#### 使用flex-wrap实现弹性盒子多行排列效果

![snipaste20220313_152319](笔记截图\snipaste20220313_152319.png)

#### 盒子模型

盒子模型由内外边距和border所组成

#### 内减模式

解决padding和border会把盒子撑大的问题

box-sizing: border-box;

#### 移动适配

###### 什么是移动适配？

宽高随着不同设备的变化而变化

###### 媒体查询

功能就是为不同屏幕设置不同大小的html字号

媒体查询能够检测视口的宽度，然后编写差异化的 CSS 样式

![snipaste20220314_104753](笔记截图\snipaste20220314_104753.png)



###### 移动适配原理

首先1rem=1html字号。什么意思？就是说假设html的字号为20px，则1rem=20px,2rem=40px。

所以移动适配的原理实际上是根据不同屏幕，设置屏幕所对应的html字号，然后再使用rem就能适配了。

那html所对应的字号应该设置为多少合适呢？参见下面的rem

##### rem

目前rem布局方案中，将网页等分成10份， HTML标签的字号为视口宽度的 1/10

![snipaste20220315_103554](笔记截图\snipaste20220315_103554.png)

###### 怎样通过设计稿得出rem单位？

* 先查看下该设计稿是基于多少视口进行设计的（比如说375px视口）
* 将375/10得出html字号的大小为37.5px
* 比如一个盒子的款式375px，则它转成rem单位为375px/37.5px=10rem

###### flexible.js

为什么要用flexible.js？

手机设备多，屏幕尺寸不一，视口不仅仅有3个，需要写跟多的媒体查询来适配

是什么？

通过flexible.js框架可以帮我们呢写媒体查询，这样提高了效率

怎么用？

使用的时候导入这个js文件即可

#### vw/vh

vw=view width

vh=view height

1vw=1/100视口宽度

vw单位的尺寸 = px单位数值 / ( 1/100 视口宽度 )

###### vw和rem的区别

* vw是直接相对视口计算，而rem是相对html的字号去计算，而html字号又是根据视口宽度去计算的
* vw不需要写媒体查询

#### Less

是什么？

Less是一个CSS预处理器, Less文件后缀是**.less**

###### 安装

less是vscode中的一个插件，在vscode插件中安装即可

###### &

&不生成后代选择器，表示当前选择器，通常配合伪类或伪元素使用
![snipaste20220317_215157](笔记截图\snipaste20220317_215157.png)

###### 设置固定属性值

![snipaste20220315_112600](笔记截图\snipaste20220315_112600.png)

###### 导入文件

![snipaste20220315_112755](笔记截图\snipaste20220315_112755.png)

###### 导出CSS文件

![snipaste20220315_112910](笔记截图\snipaste20220315_112910.png)

* 导出语句一定要放在第一行，否则会被当做注释解析

###### 禁止导出 

![snipaste20220315_113126](笔记截图\snipaste20220315_113126.png)

#### 媒体查询

![snipaste20220318_141806](笔记截图\snipaste20220318_141806.png)

![snipaste20220318_142305](笔记截图\snipaste20220318_142305.png)

###### 书写顺序

![snipaste20220318_142512](笔记截图\snipaste20220318_142512.png)

* 不按顺序会被层叠

###### 外链式引入媒体查询

![snipaste20220318_142935](笔记截图\snipaste20220318_142935.png)

### css3

##### 平面转换属性transform

###### 位移

使用translate实现元素位移效果

![snipaste20220321_155558](笔记截图/snipaste20220321_155558.png)

##### 旋转

使用rotate实现元素旋转效果

transform: rotate(角度);

注意：角度单位是deg

取值为正, 则顺时针旋转

取值为负, 则逆时针旋转

* 不加伪类选择器出不来效果

  ![snipaste20220321_161252](笔记截图/snipaste20220321_161252.png)

###### 转换原点

默认圆点是盒子中心点

语法：transform-origin: 原点水平位置 原点垂直位置; 

取值

* 方位名词（left、top、right、bottom、center） 
* 像素单位数值
* 百分比（参照盒子自身尺寸计算）

![snipaste20220321_161710](笔记截图/snipaste20220321_161710.png)

###### 多重转换

![snipaste20220321_161832](笔记截图/snipaste20220321_161832.png)

* 就是同时执行两种效果

##### 缩放

使用scale改变元素的尺寸

* 语法：transform: scale(x轴缩放倍数, y轴缩放倍数);

* 一般情况下, 只为scale设置一个值, 表示x轴和y轴等比例缩放

* transform: scale(缩放倍数);

* scale值大于1表示放大, scale值小于1表示缩小

  ![snipaste20220321_175847](笔记截图/snipaste20220321_175847.png)

##### 渐变

语法：

![snipaste20220321_181948](笔记截图/snipaste20220321_181948.png)

![snipaste20220321_181857](笔记截图/snipaste20220321_181857.png)

* 从透明到半透明

  ![snipaste20220321_182203](笔记截图/snipaste20220321_182203.png)

### 响应式网页

依托媒体查询，给内容设置不同的宽高

### bootstrap

* 里面已经包含了初始化样式，不需要自己引入了

###### 栅格系统

![snipaste20220319_132358](笔记截图/snipaste20220319_132358.png)

###### 全局css样式

给表格、标签添加css样式

使用：

1.先找到自己想要的样式

2.查看该样式的类名

3.如果自己已经有了html结构，那就修改成对应类名即可。如果没有自己的html结构，那就复制它的html结构

###### 组件

###### js插件

###### 定制

### Ajax

###### URL

（全称是UniformResourceLocator）中文叫统一资源定位符，用于标识互联网上每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源的存放位置，从而成功访问到对应的资源。

URL地址一般由三部组成：
① 客户端与服务器之间的通信协议
② 存有该资源的服务器名称
③ 资源在服务器上具体的存放位置

###### XMLHttpRequest对象

（简称 xhr）是浏览器提供的 js 成员，通过它，可以请求服务器上的数据资源。
最简单的用法 var xhrObj = new XMLHttpRequest()

###### 资源的请求方式

get 请求：向服务器要资源

post 请求：通常用于向服务器提交数据（往服务器发送资源）

* 两者都是可以传参数的

###### 什么是Ajax

Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML）。
通俗的理解：在网页中利用 XMLHttpRequest 对象和服务器进行数据交互的方式，就是Ajax。

Ajax能让我们轻松实现网页与服务器之间的数据交互。

* 网页与服务器之间数据交互的桥梁。

###### jQuery中的Ajax

浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数，极大地降低了 Ajax 的使用难度。
jQuery 中发起 Ajax 请求最常用的三个方法如下：
 $.get()
 $.post()
 $.ajax()

######  $.get()

专门用来发起 get 请求

![snipaste20220309_201845](C:\Users\俞子青\Desktop\前端笔记\笔记截图\snipaste20220309_201845.png)

* ‘utf8’和参数不能并存，两者只能取其一

* 传参只能传一个，不知道为什么？应该是接口的问题

* 传参使用的是{}

* 示例代码如下：

  ![snipaste20220317_164430](笔记截图\snipaste20220317_164430.png)

######  $.post()

专门用来发起 post 请求，从而向服务器提交数据。

![snipaste20220309_202033](笔记截图\snipaste20220309_202033.png)

* 示例代码

  ![snipaste20220317_164906](笔记截图\snipaste20220317_164906.png)

######  $.ajax()

![snipaste20220309_202109](笔记截图\snipaste20220309_202109.png)

###### 接口是什么？

使用 Ajax 请求数据时，被请求的 URL 地址，就叫做数据接口（简称接口）。同时，每个接口必须有请求方式。
例如：
http://www.liulongbin.top:3006/api/getbooks  获取图书列表的接口(GET请求)
http://www.liulongbin.top:3006/api/addbook   添加图书的接口（POST请求）

* 接口就是url地址，rul地址存放的是资源。

###### 接口文档

接口文档，顾名思义就是接口的说明文档，它是我们调用接口的依据。好的接口文档包含了对接口URL，参数以及输出内容的说明，我们参照接口文档就能方便的知道接口的作用，以及接口如何进行调用。

接口文档可以包含很多信息，也可以按需进行精简，不过，一个合格的接口文档，应该包含以下6项内容，从而为接口的调用提供依据：

1.接口名称：用来标识各个接口的简单说明，如登录接口，获取图书列表接口等。
2.接口URL：接口的调用地址。

3.调用方式：接口的调用方式，如 GET 或 POST。
4.参数格式：接口需要传递的参数，每个参数必须包含参数名称、参数类型、是否必选、参数说明这4项内容。

5.响应格式：接口的返回值的详细描述，一般包含数据名称、数据类型、说明3项内容。

6.返回示例（可选）：通过对象的形式，例举服务器返回数据的结构。

##### form表单的基本使用

###### 表单的组成

![snipaste20220315_141501](笔记截图\snipaste20220315_141501.png)

* 表单域

  ![snipaste20220315_141553](笔记截图\snipaste20220315_141553.png)

* 表单标签

  ![snipaste20220315_141620](笔记截图\snipaste20220315_141620.png)

###### form标签的属性

![snipaste20220315_141800](笔记截图\snipaste20220315_141800.png)

![snipaste20220315_141842](笔记截图\snipaste20220315_141842.png)

![snipaste20220315_141914](笔记截图\snipaste20220315_141914.png)

![snipaste20220315_141942](笔记截图\snipaste20220315_141942.png)

![snipaste20220315_142006](笔记截图\snipaste20220315_142006.png)

![snipaste20220315_142030](笔记截图\snipaste20220315_142030.png)

示例：

![snipaste20220315_142804](笔记截图\snipaste20220315_142804.png)

###### 传统表单提交的缺点

![snipaste20220315_143022](笔记截图\snipaste20220315_143022.png)

###### 传统表单提交缺点的解决方案

表单只负责采集数据，Ajax 负责将数据提交到服务器。

##### 通过Ajax提交表单数据

###### 步骤

1. 获得表单中的数据
2. 用post请求提交数据

###### serialize()函数

![snipaste20220315_151306](笔记截图\snipaste20220315_151306.png)

示例：

![snipaste20220315_151732](笔记截图\snipaste20220315_151732.png)

![snipaste20220315_151822](笔记截图\snipaste20220315_151822.png)

![snipaste20220316_133143](笔记截图\snipaste20220316_133143.png)

* 示例代码

  ```
  <!DOCTYPE html>
  <html lang="en">
  
  <head>
      <meta charset="UTF-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
      <script src="./lib/jquery.js"></script>
  </head>
  
  <body>
      <!-- 首先你得做一个表单吧 -->
      <form action="" target="_self" method="post" id="fo">
          <!-- 表单中几个属性要记牢 -->
          <input type="text" name="txt">
          <button type="submit">提交</button>
      </form>
  
      <!-- 
      传统表单提交数据的缺点是：
      1、一提交页面就会跳转
      2、页面的数据会丢失 
  
      解决问题的方法：
      1、对于第一个问题，给表单添加一个阻止默认跳转
      2、对于第二个问题，用serialize方法来获取表单数据，存储数据的表单一定要加name属性
      -->
  
      <script>
          $('#fo').on('submit', function(e) {
              e.preventDefault(); //解决了第一个问题
              var txt = $(this).serialize();
              console.log(txt);
          })
      </script>
  </body>
  
  </html>
  ```

##### 模板引擎

###### 渲染UI结构时遇到的问题

* 就理解为传统的渲染方式比较繁琐

![snipaste20220315_205458](笔记截图\snipaste20220315_205458.png)

###### 什么是模板引擎

![snipaste20220315_205559](笔记截图\snipaste20220315_205559.png)

######  模板引擎的好处

![snipaste20220315_205629](笔记截图\snipaste20220315_205629.png)

#### art-template模板引擎

中文官网首页为 http://aui.github.io/art-template/zh-cn/index.html

###### art-template的安装

在浏览器中访问 http://aui.github.io/art-template/zh-cn/docs/installation.html 页面，找到下载链接后，鼠标右键，选择“链接另存为”，将 art-template 下载到本地，然后，通过 <script> 标签加载到网页上进行使用。

###### art-template模板引擎的基本使用

![snipaste20220316_092113](笔记截图\snipaste20220316_092113.png)

###### 定义模板引擎

* 定义模板引擎的时候一定要定义在<script></script>中，而且<script></script>标签的属性值type要改成text/html，其默认是text/javascript，及按js来解析，而我们的模板引擎要按html来解析。示例代码：

![snipaste20220317_181320](笔记截图\snipaste20220317_181320.png)

* 模板一定要定义在js代码的前面，否则会报错。

###### 调用template函数

* template函数需要两个参数：id（模板的id）和数据。
* template函数的返回值是一个字符串
* 最后将返回值添加（html()/append()...）到盒子中就行

#####  art-template语法

###### 输出

![snipaste20220316_092245](笔记截图\snipaste20220316_092245.png)

###### 原文输出

![snipaste20220316_092600](笔记截图\snipaste20220316_092600.png)

###### 条件输出

![snipaste20220316_093244](笔记截图\snipaste20220316_093244.png)

###### 循环输出

![snipaste20220316_093532](笔记截图\snipaste20220316_093532.png)

###### 过滤器

![snipaste20220316_093558](笔记截图\snipaste20220316_093558.png)

![snipaste20220316_093629](笔记截图\snipaste20220316_093629.png)

示例：

![snipaste20220316_093823](笔记截图\snipaste20220316_093823.png)

* 你的时间传进来一定要转换成日期对象，否则你凭什么调用一下日期对象的方法（date.getFullYear()）？转换成日期对象的语法为：new Date(date);当然，如果传进来的就是一个日期对象，那肯定就不用这一步了。上面的代码本身就是一个日期对象，所以不用。而下面的代码不是，所以要转换。示例代码如下：

  ![snipaste20220318_103101](笔记截图\snipaste20220318_103101.png)

* 下面的代码很有参考价值，对复习理解上述语法有很大帮助

  ```
  <!DOCTYPE html>
  <html lang="en">
  
  <head>
      <meta charset="UTF-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
      <script src="./lib/jquery.js"></script>
      <!-- 1、先引入模板引擎 -->
      <script src="./lib/template-web.js"></script>
  </head>
  
  <body>
      <ul>
          <!-- 
          <li></li>
          <li>姓名是：</li>
          <li>年龄是：</li>
          <li>是否是vip：</li>
          <li>注册日期是：</li>
          <li>爱好是：</li> 
           -->
      </ul>
  
      <script type="text/html" id="tpl">
          <!-- 3、定义模板 -->
          <li>{{@title}}</li>
          <!-- 存放用户信息 -->
          <li>姓名是：{{name}}</li>
          <li>年龄是：{{20}}</li>
          <li>是否是vip：{{isVIP?'是':'不是'}}</li>
          <li>注册日期是：{{regTime | dateFormat}}</li>
          <li>爱好是：{{each hobby}}{{$value}}{{','}}{{/each}}</li>
      </script>
  
      <script>
          var data = {
                  title: '<h3>用户信息</h3>',
                  name: 'zs',
                  age: 20,
                  isVIP: true,
                  regTime: new Date(),
                  hobby: ['吃饭', '睡觉', '打豆豆']
              }
              //要将上面这个对象的数据渲染到页面对应的结构当中
              // 2、定义数据：就是上面的这个data对象
  
          // 6. 定义过滤器
          template.defaults.imports.dateFormat = function(regTime) {
              var y = regTime.getFullYear();
              var m = regTime.getMonth() + 1;
              var d = regTime.getDate();
              return y + '-' + m + '-' + d;
          }
  
          //4.调用template函数
          var contain = template('tpl', data);
          // 5.将模板添加到页面中
          $('ul').html(contain);
      </script>
  </body>
  
  </html>
  ```

#### XMLHttpRequest的基本使用

###### 什么是XMLHttpRequest

XMLHttpRequest（简称 xhr）是浏览器提供的 Javascript 对象，通过它，可以请求服务器上的数据资源。之前所学的 jQuery 中的 Ajax 函数，就是基于 xhr 对象封装出来的。

![snipaste20220321_091426](笔记截图/snipaste20220321_091426.png)

* xhr是比Ajax更底层的东西

###### 使用xhr发起GET请求

![snipaste20220321_091746](笔记截图/snipaste20220321_091746.png)

<img src="笔记截图/snipaste20220321_091820.png" alt="snipaste20220321_091820" style="zoom:67%;" />

###### 了解xhr对象的readyState属性

![snipaste20220321_092832](笔记截图/snipaste20220321_092832.png)

###### 使用xhr发起带参数的GET请求

![snipaste20220321_092914](笔记截图/snipaste20220321_092914.png)

##### 查询字符串

###### 什么是查询字符串

![snipaste20220321_092955](笔记截图/snipaste20220321_092955.png)

###### GET请求携带参数的本质

![snipaste20220321_093025](笔记截图/snipaste20220321_093025.png)

##### URL编码与解码

###### 什么是URL编码

![snipaste20220321_093107](笔记截图/snipaste20220321_093107.png)

###### 如何对URL进行编码与解码

![snipaste20220321_093153](笔记截图/snipaste20220321_093153.png)

###### URL编码的注意事项

![snipaste20220321_093230](笔记截图/snipaste20220321_093230.png)

##### 使用xhr发起POST请求

![snipaste20220321_093313](笔记截图/snipaste20220321_093313.png)

![snipaste20220321_093331](笔记截图/snipaste20220321_093331.png)

#### 数据交换格式

###### 什么是数据交换格式

![snipaste20220321_094104](笔记截图/snipaste20220321_094104.png)

##### XML

###### 什么是XML

![snipaste20220321_094350](笔记截图/snipaste20220321_094350.png)

###### XML和HTML的区别

![snipaste20220321_094417](笔记截图/snipaste20220321_094417.png)

###### XML的缺点

![snipaste20220321_094439](笔记截图/snipaste20220321_094439.png)

##### JSON

###### 什么是JSON

![snipaste20220321_094634](笔记截图/snipaste20220321_094634.png)

###### JSON有什么用

服务器返回的数据一般是json格式的，如下：

![snipaste20220321_100250](笔记截图/snipaste20220321_100250.png)

这种数据对我们的使用不是很方便，要将他转成对象格式的数据，转换方法如下：

![snipaste20220321_100451](笔记截图/snipaste20220321_100451.png)

![snipaste20220321_100445](笔记截图/snipaste20220321_100445.png)

###### JSON的两种结构

![snipaste20220321_094709](笔记截图/snipaste20220321_094709.png)

![snipaste20220321_094738](笔记截图/snipaste20220321_094738.png)

![snipaste20220321_094828](笔记截图/snipaste20220321_094828.png)

###### JSON语法注意事项

![snipaste20220321_094929](笔记截图/snipaste20220321_094929.png)

###### JSON和JS对象的关系

![snipaste20220321_095015](笔记截图/snipaste20220321_095015.png)

###### JSON和JS对象的互转

![snipaste20220321_095102](笔记截图/snipaste20220321_095102.png)

###### 序列化和反序列化

![snipaste20220321_095133](笔记截图/snipaste20220321_095133.png)

#### XMLHttpRequest Level2的新特性

XMLHttpRequest Level2：新版的XMLHttpRequest

###### 旧版XMLHttpRequest的缺点

![snipaste20220321_095326](笔记截图/snipaste20220321_095326.png)

###### XMLHttpRequest Level2的新功能

![snipaste20220321_095353](笔记截图/snipaste20220321_095353.png)

###### 设置HTTP请求时限

![snipaste20220321_095436](笔记截图/snipaste20220321_095436.png)

###### FormData对象管理表单数据

![snipaste20220321_095723](笔记截图/snipaste20220321_095723.png)

![snipaste20220321_100613](笔记截图/snipaste20220321_100613.png)

* 这个和serialieze()的区别：serialieze()是先要得到数据，然后将数据以参数形式发送post请求。而这个是不需要获得表单里面的数据，直接获得表单元素之后发送表单元素就好了。
* xhr和$.post相比还是有优势的，起码看起来提交表单它是比较方便，但是不是真方便还要看后期的实践。

###### 上传文件

![snipaste20220321_101300](笔记截图/snipaste20220321_101300.png)

![snipaste20220321_101323](笔记截图/snipaste20220321_101323.png)

![snipaste20220321_101348](笔记截图/snipaste20220321_101348.png)

![snipaste20220321_101642](笔记截图/snipaste20220321_101642.png)

![snipaste20220321_101851](笔记截图/snipaste20220321_101851.png)

![snipaste20220321_102006](笔记截图/snipaste20220321_102006.png)

###### 显示文件上传进度

![snipaste20220321_102059](笔记截图/snipaste20220321_102059.png)

![snipaste20220321_102340](笔记截图/snipaste20220321_102340.png)

![snipaste20220321_102403](笔记截图/snipaste20220321_102403.png)

![snipaste20220321_102527](笔记截图/snipaste20220321_102527.png)

![snipaste20220321_102703](笔记截图/snipaste20220321_102703.png)

###### jQuery实现文件上传

![snipaste20220321_102759](笔记截图/snipaste20220321_102759.png)

![snipaste20220321_102824](笔记截图/snipaste20220321_102824.png)

![snipaste20220321_102840](笔记截图/snipaste20220321_102840.png)

![snipaste20220321_102916](笔记截图/snipaste20220321_102916.png)

######  jQuery实现loading效果

![snipaste20220321_103118](笔记截图/snipaste20220321_103118.png)

![snipaste20220321_114226](笔记截图/snipaste20220321_114226.png)

### HTTP

###### 什么是通信

![snipaste20220321_141740](笔记截图/snipaste20220321_141740.png)

###### 什么是通信协议

![snipaste20220321_141844](笔记截图/snipaste20220321_141844.png)

![snipaste20220321_141907](笔记截图/snipaste20220321_141907.png)

###### 什么是HTTP协议

![snipaste20220321_141936](笔记截图/snipaste20220321_141936.png)

###### HTTP协议的交互模型

![snipaste20220321_142017](笔记截图/snipaste20220321_142017.png)

###### 什么是HTTP请求消息

![snipaste20220321_142052](笔记截图/snipaste20220321_142052.png)

#####  HTTP请求消息的组成部分

![snipaste20220321_142125](笔记截图/snipaste20220321_142125.png)

###### 请求行

![snipaste20220321_142503](笔记截图/snipaste20220321_142503.png)

###### 请求头部

![snipaste20220321_142726](笔记截图/snipaste20220321_142726.png)

![snipaste20220321_142703](笔记截图/snipaste20220321_142703.png)

![snipaste20220321_143518](笔记截图/snipaste20220321_143518.png)

###### 空行

![snipaste20220321_143555](笔记截图/snipaste20220321_143555.png)

###### 请求体

![snipaste20220321_143658](笔记截图/snipaste20220321_143658.png)

![snipaste20220321_143746](笔记截图/snipaste20220321_143746.png)

##### 什么是HTTP响应消息

![snipaste20220321_143856](笔记截图/snipaste20220321_143856.png)

##### HTTP响应消息的组成部分

![snipaste20220321_144026](笔记截图/snipaste20220321_144026.png)

###### 状态行

![snipaste20220321_144135](笔记截图/snipaste20220321_144135.png)

###### 响应头部

![snipaste20220321_144156](笔记截图/snipaste20220321_144156.png)

![snipaste20220321_144225](笔记截图/snipaste20220321_144225.png)

###### 空行

![snipaste20220321_144540](笔记截图/snipaste20220321_144540.png)

###### 响应体

![snipaste20220321_144601](笔记截图/snipaste20220321_144601.png)

##### 什么是HTTP请求方法

![snipaste20220321_144634](笔记截图/snipaste20220321_144634.png)

![snipaste20220321_144656](笔记截图/snipaste20220321_144656.png)

##### 什么是HTTP响应状态码

![snipaste20220321_144721](笔记截图/snipaste20220321_144721.png)

##### HTTP响应状态码的组成及分类

![snipaste20220321_144804](笔记截图/snipaste20220321_144804.png)

###### 2** 成功相关的响应状态码

![snipaste20220321_144840](笔记截图/snipaste20220321_144840.png)

###### 3** 重定向相关的响应状态码

![snipaste20220321_144904](笔记截图/snipaste20220321_144904.png)

###### 4** 客户端错误相关的响应状态码

![snipaste20220321_144923](笔记截图/snipaste20220321_144923.png)

###### 5** 服务端错误相关的响应状态码

![snipaste20220321_144950](笔记截图/snipaste20220321_144950.png)

### 前端工程化

#### webpack

###### 什么是 webpack

webpack 是前端项目工程化的具体解决方案

###### 主要功能

它提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端 JavaScript 的兼容性、性

能优化等强大的功能。

##### webpack 的基本使用

### Node.js

###### 浏览器中的 JavaScript 的组成部分

![snipaste20220314_192729](笔记截图\snipaste20220314_192729.png)

###### 浏览器中的 JavaScript 运行环境

运行环境是指代码正常运行所需的必要环境。

![snipaste20220314_192924](笔记截图\snipaste20220314_192924.png)

###### 什么是 Node.js

Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。

![snipaste20220314_193044](笔记截图\snipaste20220314_193044.png)

###### Node.js 怎么学

![snipaste20220314_193156](笔记截图\snipaste20220314_193156.png)

###### Node.js 环境的安装

如果希望通过 Node.js 来运行 Javascript 代码，则必须在计算机上安装 Node.js 环境才行。

###### 什么是终端

终端（英文：Terminal）是专门为开发人员设计的，用于实现人机交互的一种方式。

###### 模块相当于bom和dom

##### 文件系统模块

![snipaste20220314_194133](笔记截图\snipaste20220314_194133.png)

###### 读取指定文件中的内容

![snipaste20220314_194226](笔记截图\snipaste20220314_194226.png)

![snipaste20220314_202115](笔记截图\snipaste20220314_202115.png)

如果读取成功，则 err 的值为 null

如果读取失败，则 err 的值为 错误对象，dataStr 的值为 undefined

###### 向指定的文件中写入内容

![snipaste20220316_121654](笔记截图\snipaste20220316_121654.png)

![snipaste20220316_121718](笔记截图\snipaste20220316_121718.png)

#####  path 路径模块

###### 什么是 path 路径模块

path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理

需求。

![snipaste20220316_124716](笔记截图\snipaste20220316_124716.png)

###### 路径拼接

![snipaste20220316_124810](C:\Users\俞子青\Desktop\前端笔记\笔记截图\snipaste20220316_124810.png)

![snipaste20220316_124838](笔记截图\snipaste20220316_124838.png)

###### __dirname

* __dirname是当前文件所处目录

* 注意是两条杠

###### 获取路径中的文件名

path.basename() 

![snipaste20220316_125811](笔记截图\snipaste20220316_125811.png)

![snipaste20220316_125837](笔记截图\snipaste20220316_125837.png)

###### 获取路径中的文件扩展名

![snipaste20220316_125905](笔记截图\snipaste20220316_125905.png)

![snipaste20220316_125919](笔记截图\snipaste20220316_125919.png)

#####  http 模块

![snipaste20220317_135950](笔记截图\snipaste20220317_135950.png)

![snipaste20220317_140227](笔记截图\snipaste20220317_140227.png)

##### 服务器相关的概念

###### IP 地址

![snipaste20220317_140418](笔记截图\snipaste20220317_140418.png)

![snipaste20220317_140548](笔记截图\snipaste20220317_140548.png)

######  域名和域名服务器

![snipaste20220317_141552](笔记截图\snipaste20220317_141552.png)

###### 端口号

![snipaste20220317_141658](笔记截图\snipaste20220317_141658.png)

###### 创建 web 服务器的基本步骤

![snipaste20220317_141826](笔记截图\snipaste20220317_141826.png)

![snipaste20220317_141851](笔记截图\snipaste20220317_141851.png)

![snipaste20220317_142414](笔记截图\snipaste20220317_142414.png)

![snipaste20220317_142534](笔记截图\snipaste20220317_142534.png)

![snipaste20220317_142549](笔记截图\snipaste20220317_142549.png)

### Git

###### 版本控制软件

把手工管理文件版本的方式，改为由软件管理文件的版本；

这个负责管理文件版本的软件，叫做“版本控制软件”。

###### 什么是 Git

Git 是一个开源的分布式版本控制系统，是目前世界上最先进、最流行的版本控制系统。可以快速高效地处理从很小到非常大的项目版本管理。

###### Git 的记录快照

Git 快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。

###### Git 中的三个区域

分别是工作区、暂存区、Git 仓库

![snipaste20220316_100733](笔记截图\snipaste20220316_100733.png)

###### 安装并配置 Git

在开始使用 Git 管理项目的版本之前，需要将它安装到计算机上。可以使用浏览器访问如下的网址，根据自己

的操作系统，选择下载对应的 Git 安装包：

https://git-scm.com/downloads

###### 配置用户信息

在Git Bash中进行配置

![snipaste20220316_101807](笔记截图\snipaste20220316_101807.png)

```
git config --global user.name "Lance"

git config --global user.email "2876359705@qq.com"
```

![snipaste20220316_102401](笔记截图\snipaste20220316_102401.png)

###### 获取帮助信息

![snipaste20220316_102502](笔记截图\snipaste20220316_102502.png)

```
git help config
git config -h
```

###### 获取 Git 仓库的两种方式

① 将尚未进行版本控制的本地目录**转换**为 Git 仓库

② 从其它服务器**克隆**一个已存在的 Git 仓库

以上两种方式都能够在自己的电脑上得到一个可用的 Git 仓库

1. **在现有目录中初始化仓库**

   ![snipaste20220316_111840](笔记截图\snipaste20220316_111840.png)

###### 工作区中文件的 4 种状态

![snipaste20220316_112349](笔记截图\snipaste20220316_112349.png)

仔细理解下，挺容易的

###### 检查文件的状态

![snipaste20220316_112750](笔记截图\snipaste20220316_112750.png)

###### 以精简的方式显示文件状态

![snipaste20220316_112918](笔记截图\snipaste20220316_112918.png)

###### 跟踪新文件

![snipaste20220316_113016](笔记截图\snipaste20220316_113016.png)

###### 提交更新

![snipaste20220316_113254](笔记截图\snipaste20220316_113254.png)

###### 对已提交的文件进行修改

![snipaste20220316_113523](笔记截图\snipaste20220316_113523.png)

###### 暂存已修改的文件

![snipaste20220316_113834](笔记截图\snipaste20220316_113834.png)

* 这一步可以直接省略，只要该文件被跟踪后，无论它是否被修改，都可直接提交到仓库中，不需要再放到暂存取中

###### 提交已暂存的文件

![snipaste20220316_114021](笔记截图\snipaste20220316_114021.png)

###### 撤销对文件的修改

![snipaste20220316_114141](笔记截图\snipaste20220316_114141.png)

撤销是你没提交到git库中执行才有效果，如果你都执行了提交操作，那是无法撤销的

另外你如果添加到暂存区也是无法撤销的。

###### 向暂存区中一次性添加多个文件

![snipaste20220316_115325](笔记截图\snipaste20220316_115325.png)

###### 取消暂存的文件

![snipaste20220316_115529](笔记截图\snipaste20220316_115529.png)

######  跳过使用暂存区域

![snipaste20220316_115625](笔记截图\snipaste20220316_115625.png)

###### 移除文件

![snipaste20220316_115755](笔记截图\snipaste20220316_115755.png)

###### 忽略文件

![snipaste20220317_100222](笔记截图\snipaste20220317_100222.png)

![snipaste20220317_100633](笔记截图\snipaste20220317_100633.png)

![snipaste20220317_100738](笔记截图\snipaste20220317_100738.png)

需要创建这个忽略文件，在这个文件中配置忽略上述规则

* 忽略规则中的那些文件不再显示未跟踪，但这个忽略文件会显示未跟踪，需要把这个忽略文件跟踪后提交

###### 查看提交历史

![snipaste20220317_101916](笔记截图\snipaste20220317_101916.png)

* 按q退出查询

###### Git快捷键

clear:清屏

######  回退到指定的版本

![snipaste20220317_102124](笔记截图\snipaste20220317_102124.png)

* 怎么用？先在一行上展示所有的提交历史，每个历史都会有一个唯一标识符。将你想要的回退版本的唯一标识符赋给CommitID，执行git reset --hard命令即可

##### Github

###### 开源项目托管平台

![snipaste20220317_103004](笔记截图\snipaste20220317_103004.png)

###### 注册账号

用户名：LanceYu1

账号：2876359705@qq.com

密码：shdfh3767

###### 新建空白远程仓库

###### GitHub地址

https://github.com/LanceYu1

##### 远程仓库的两种访问方式

![snipaste20220317_104332](笔记截图\snipaste20220317_104332.png)

###### 基于 HTTPS 将本地仓库上传到 Github

![snipaste20220317_104602](笔记截图\snipaste20220317_104602.png)

* 上述代码只需第一次时运行，后续本地代码更新后如果要同步到github，只需要在git中执行git push命令

###### git push命令

本地代码更新后，在git bush中提交到git仓库后，执行git push命令，将代码同步到gitHub仓库

###### 基于 SSH 将本地仓库上传到 Github

* SSH key

  ![snipaste20220317_123125](笔记截图\snipaste20220317_123125.png)

* **生成 SSH key**

  ![snipaste20220317_123217](笔记截图\snipaste20220317_123217.png)

  ```
  ssh-keygen -t rsa -b 4096 -C "2876359705@qq.com"
  ```

* **配置 SSH key**

  ![snipaste20220317_123640](笔记截图\snipaste20220317_123640.png)

* **检测 Github 的 SSH key 是否配置成功**

  ![snipaste20220317_124147](笔记截图\snipaste20220317_124147.png)

  ![snipaste20220317_124322](笔记截图\snipaste20220317_124322.png)

###### 将远程仓库克隆到本地

![snipaste20220317_125321](笔记截图\snipaste20220317_125321.png)

##### Git 分支

###### 分支在实际开发中的作用

![snipaste20220317_125526](笔记截图\snipaste20220317_125526.png)

* 代码不能在主分支上写，这样不安全，要在新建分支上写，新建分支是主分支的一个副本。新建分支上的代码写完后，要合并到主分支上。

######  master 主分支

![snipaste20220317_125600](笔记截图\snipaste20220317_125600.png)

###### 功能分支

![snipaste20220317_125630](笔记截图\snipaste20220317_125630.png)

##### 本地分支操作

###### 查看分支列表

![snipaste20220317_125813](笔记截图\snipaste20220317_125813.png)

###### 创建新分支

![snipaste20220317_125855](笔记截图\snipaste20220317_125855.png)

* 新分支中的代码和当前分支完全一样：也就说是当前分支的一个副本

###### 切换分支

![snipaste20220317_125954](笔记截图\snipaste20220317_125954.png)

###### 分支的快速创建和切换

![snipaste20220317_130127](笔记截图\snipaste20220317_130127.png)

######  合并分支

![snipaste20220318_084809](笔记截图\snipaste20220318_084809.png)

###### 删除分支

![snipaste20220318_090619](笔记截图\snipaste20220318_090619.png)

###### 遇到冲突时的分支合并

![snipaste20220318_091430](笔记截图\snipaste20220318_091430.png)

* 什么情况下会遇到两个分支产生冲突？在a和b分支上对相同的代码做了不同的修改，两者提交的git仓库中后，要合并到主分支上的时候会产生冲突。但如果两个分支先后已经合并到主分支上的时候是不会产生冲突的。

###### 将本地分支推送到远程仓库

![snipaste20220318_092948](笔记截图\snipaste20220318_092948.png)

###### 查看远程仓库中所有的分支列表

![snipaste20220318_093633](笔记截图\snipaste20220318_093633.png)

###### 跟踪分支

![snipaste20220318_093737](笔记截图\snipaste20220318_093737.png)

###### 拉取远程分支的最新的代码

![snipaste20220318_094515](笔记截图\snipaste20220318_094515.png)

###### 移除Git版本管理

find . -name ".git" | xargs rm -Rf

###### Master

* 只有master主分支中有东西，且提交了能创建新的分支

###### ssh地址

```
git@github.com:LanceYu1/11111.git
```

###### 从GitHub上拉代码及后续操作

1. 首先在自己的电脑上安装git，然后配置好信息
2. 直接克隆远程仓库就行。

![snipaste20220317_125321](笔记截图\snipaste20220317_125321.png)

3. 下载下来的代码应该是主分支上的代码，此时应该创建一个新分支，在新分支上修改代码，修改完之后合并到主分支上。

4. 注意：你下载下来的代码已经被git所管理了，因为它自动有git文件

   ![snipaste20220320_112140](笔记截图/snipaste20220320_112140.png)

5. 并且还不用建立连接？就可以直接push到远程仓库中？我觉的是两个原因所导致的：一个是你配置git的时候是用的全局配置，基本的用户信息没有改变；二是用的ssh建立的连接，你的本地上已经有了一份密钥。

###### 如何上传本地的分支到远程仓库呢？

* 第一次上传

  ![snipaste20220318_092948](笔记截图\snipaste20220318_092948.png)

###### 如何下载远程仓库中的分支呢？

![snipaste20220318_093737](笔记截图\snipaste20220318_093737.png)

###### 删除远程分支

![snipaste20220318_094543](笔记截图\snipaste20220318_094543.png)

###### origin库

![snipaste20220320_152224](笔记截图/snipaste20220320_152224.png)

* 人家的第一行命令就把这个库命名成origin了
* 第二行就添加了一个main分支

###### 第一次向远程仓库提交代码

![snipaste20220320_152224](笔记截图/snipaste20220320_152224.png)

### vue

###### vue是什么？

![snipaste20220321_174243](笔记截图/snipaste20220321_174243.png)

### 待解决的问题

###### vertical-align的使用

###### 行高问题

![snipaste20220314_124954](笔记截图\snipaste20220314_124954.png)

![snipaste20220314_124946](笔记截图\snipaste20220314_124946.png)

###### bootstrap箭头显示不出来

![snipaste20220318_190611](笔记截图\snipaste20220318_190611.png)

* bootstrap引用的时候要基于jQuery

### ASCII 表

![图片1](笔记截图\图片1.png)

### 不熟悉的地方

* 怎么创建一个元素
* 三种获取元素 内容值的方式你真的掌握清楚了吗？
* 删除一个元素？？？？？？？？
* 定时器
* 怎么添加多个监听事件？
* 设置固有属性
* 字符串的分割
* 绝对定位
* less的导入语句
* for(var k in obj) { 
  //k 得到的是属性名
  //obj是所遍历的对象
  //obj[k] 得到是属性值
  }
* 字符串的截取
* 

